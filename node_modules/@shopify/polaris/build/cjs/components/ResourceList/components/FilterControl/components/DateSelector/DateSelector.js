'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisIcons = require('@shopify/polaris-icons');
var DateSelector$1 = require('./DateSelector.scss.js');
var DatePicker = require('../../../../../DatePicker/DatePicker.js');
var Select = require('../../../../../Select/Select.js');
var hooks = require('../../../../../../utilities/i18n/hooks.js');
var TextField = require('../../../../../TextField/TextField.js');
var Icon = require('../../../../../Icon/Icon.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

const VALID_DATE_REGEX = /^\d{4}-\d{1,2}-\d{1,2}$/;
exports.DateFilterOption = void 0;

(function (DateFilterOption) {
  DateFilterOption["PastWeek"] = "past_week";
  DateFilterOption["PastMonth"] = "past_month";
  DateFilterOption["PastQuarter"] = "past_quarter";
  DateFilterOption["PastYear"] = "past_year";
  DateFilterOption["ComingWeek"] = "coming_week";
  DateFilterOption["ComingMonth"] = "coming_month";
  DateFilterOption["ComingQuarter"] = "coming_quarter";
  DateFilterOption["ComingYear"] = "coming_year";
  DateFilterOption["OnOrBefore"] = "on_or_before";
  DateFilterOption["OnOrAfter"] = "on_or_after";
})(exports.DateFilterOption || (exports.DateFilterOption = {}));

const DateSelector = /*#__PURE__*/React.memo(function DateSelector({
  filterValue,
  filterKey,
  filterMinKey,
  filterMaxKey,
  dateOptionType,
  onFilterValueChange,
  onFilterKeyChange
}) {
  const now = new Date();
  const i18n = hooks.useI18n();
  const initialConsumerFilterKey = React.useRef(filterKey);
  const [datePickerMonth, setDatePickerMonth] = React.useState(now.getMonth());
  const [datePickerYear, setDatePickerYear] = React.useState(now.getFullYear());
  const [selectedDate, setSelectedDate] = React.useState();
  const [userInputDate, setUserInputDate] = React.useState();
  const [userInputDateError, setUserInputDateError] = React.useState();
  const dateTextFieldValue = getDateTextFieldValue();
  const handleDateFieldChange = React.useCallback(value => {
    if (value.length === 0) {
      setSelectedDate(undefined);
      onFilterValueChange(undefined);
    }

    if (userInputDateError && isValidDate(value)) {
      setUserInputDateError(undefined);
    }

    setUserInputDate(value);
  }, [onFilterValueChange, userInputDateError]);
  const handleDateChanged = React.useCallback(date => {
    if (!date) {
      return;
    }

    onFilterValueChange(stripTimeFromISOString(formatDateForLocalTimezone(date)));
  }, [onFilterValueChange]);
  const handleDateBlur = React.useCallback(() => {
    if (!dateTextFieldValue || !isValidDate(dateTextFieldValue)) {
      setSelectedDate(undefined);
      setUserInputDateError(i18n.translate('Polaris.ResourceList.DateSelector.dateValueError'));
      onFilterValueChange(undefined);
      return;
    }

    if (!userInputDate) {
      return;
    }

    const formattedDateForTimezone = new Date(formatDateForLocalTimezone(new Date(userInputDate)));
    setSelectedDate(formattedDateForTimezone);
    setDatePickerMonth(formattedDateForTimezone.getMonth());
    setDatePickerYear(formattedDateForTimezone.getFullYear());
    setUserInputDate(undefined);
    setUserInputDateError(undefined);
    handleDateChanged(formattedDateForTimezone);
  }, [dateTextFieldValue, handleDateChanged, i18n, onFilterValueChange, userInputDate]);
  const handleDateFilterOptionsChange = React.useCallback(newOption => {
    if (!initialConsumerFilterKey.current) {
      return;
    }

    if (newOption === exports.DateFilterOption.OnOrBefore) {
      onFilterKeyChange(filterMaxKey);
      onFilterValueChange(selectedDate ? stripTimeFromISOString(formatDateForLocalTimezone(selectedDate)) : undefined);
      return;
    }

    if (newOption === exports.DateFilterOption.OnOrAfter) {
      onFilterKeyChange(filterMinKey);
      onFilterValueChange(selectedDate ? stripTimeFromISOString(formatDateForLocalTimezone(selectedDate)) : undefined);
      return;
    }

    onFilterKeyChange(initialConsumerFilterKey.current);
    onFilterValueChange(newOption);
  }, [filterMaxKey, filterMinKey, initialConsumerFilterKey, onFilterKeyChange, onFilterValueChange, selectedDate]);
  const handleDatePickerChange = React.useCallback(({
    end: nextDate
  }) => {
    const date = new Date(nextDate);
    setSelectedDate(date);
    setUserInputDate(undefined);
    setUserInputDateError(undefined);
    handleDateChanged(date);
  }, [handleDateChanged]);
  const handleDatePickerMonthChange = React.useCallback((month, year) => {
    setDatePickerMonth(month);
    setDatePickerYear(year);
  }, []);
  const dateFilterOption = getDateFilterOption(filterValue, filterKey, filterMinKey, filterMaxKey);
  const showDatePredicate = dateFilterOption === exports.DateFilterOption.OnOrBefore || dateFilterOption === exports.DateFilterOption.OnOrAfter;
  const datePredicateMarkup = showDatePredicate && /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement("div", {
    className: DateSelector$1['default'].DateTextField
  }, /*#__PURE__*/React__default['default'].createElement(TextField.TextField, {
    label: i18n.translate('Polaris.ResourceList.DateSelector.dateValueLabel'),
    placeholder: i18n.translate('Polaris.ResourceList.DateSelector.dateValuePlaceholder'),
    value: dateTextFieldValue,
    error: userInputDateError,
    prefix: /*#__PURE__*/React__default['default'].createElement(Icon.Icon, {
      source: polarisIcons.CalendarMinor,
      color: "subdued"
    }),
    autoComplete: "off",
    onChange: handleDateFieldChange,
    onBlur: handleDateBlur
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: DateSelector$1['default'].DatePicker
  }, /*#__PURE__*/React__default['default'].createElement(DatePicker.DatePicker, {
    selected: selectedDate,
    month: datePickerMonth,
    year: datePickerYear,
    onChange: handleDatePickerChange,
    onMonthChange: handleDatePickerMonthChange
  })));
  const dateOptionTypes = {
    past: [...getDatePastOptions(), ...getDateComparatorOptions()],
    future: [...getDateFutureOptions(), ...getDateComparatorOptions()],
    full: [...getDatePastOptions(), ...getDateFutureOptions(), ...getDateComparatorOptions()]
  };
  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement(Select.Select, {
    label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.dateFilterLabel'),
    labelHidden: true,
    options: dateOptionType ? dateOptionTypes[dateOptionType] : dateOptionTypes.full,
    placeholder: i18n.translate('Polaris.ResourceList.FilterValueSelector.selectFilterValuePlaceholder'),
    value: dateFilterOption,
    onChange: handleDateFilterOptionsChange
  }), datePredicateMarkup);

  function getDateComparatorOptions() {
    return [{
      value: exports.DateFilterOption.OnOrBefore,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.OnOrBefore')
    }, {
      value: exports.DateFilterOption.OnOrAfter,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.OnOrAfter')
    }];
  }

  function getDatePastOptions() {
    return [{
      value: exports.DateFilterOption.PastWeek,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.PastWeek')
    }, {
      value: exports.DateFilterOption.PastMonth,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.PastMonth')
    }, {
      value: exports.DateFilterOption.PastQuarter,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.PastQuarter')
    }, {
      value: exports.DateFilterOption.PastYear,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.PastYear')
    }];
  }

  function getDateFutureOptions() {
    return [{
      value: exports.DateFilterOption.ComingWeek,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.ComingWeek')
    }, {
      value: exports.DateFilterOption.ComingMonth,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.ComingMonth')
    }, {
      value: exports.DateFilterOption.ComingQuarter,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.ComingQuarter')
    }, {
      value: exports.DateFilterOption.ComingYear,
      label: i18n.translate('Polaris.ResourceList.DateSelector.SelectOptions.ComingYear')
    }];
  }

  function getDateTextFieldValue() {
    if (!userInputDate && !selectedDate) {
      return undefined;
    }

    if (userInputDate !== undefined) {
      return userInputDate;
    }

    if (selectedDate) {
      return stripTimeFromISOString(formatDateForLocalTimezone(selectedDate));
    }
  }
});

function isValidDate(date) {
  if (!date) {
    return false;
  }

  return VALID_DATE_REGEX.test(date) && !isNaN(new Date(date).getTime());
}

function getDateFilterOption(filterValue, filterKey, filterMinKey, filterMaxKey) {
  if (filterKey === filterMaxKey) {
    return exports.DateFilterOption.OnOrBefore;
  }

  if (filterKey === filterMinKey) {
    return exports.DateFilterOption.OnOrAfter;
  }

  return filterValue;
}

function stripTimeFromISOString(ISOString) {
  return ISOString.slice(0, 10);
}

function formatDateForLocalTimezone(date) {
  const timezoneOffset = date.getTimezoneOffset();
  const timezoneOffsetMs = timezoneOffset * 60 * 1000;
  const isFringeTimezone = timezoneOffset === -720 || timezoneOffset === 720;
  const formattedDate = new Date();

  if (isFringeTimezone && date.getHours() !== 0) {
    return date.toISOString();
  }

  const newTime = timezoneOffset > -1 ? date.getTime() + timezoneOffsetMs : date.getTime() - timezoneOffsetMs;
  formattedDate.setTime(newTime);
  return formattedDate.toISOString();
}

exports.DateSelector = DateSelector;
